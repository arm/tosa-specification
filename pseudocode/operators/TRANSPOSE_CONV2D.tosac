//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

ERROR_IF(in_t != i8_t  && input_zp != 0); // Zero point only allowed for int8_t
ERROR_IF(weight_t != i8_t && weight_zp != 0);
ERROR_IF(out_pad_top <= -KH || out_pad_bottom <= -KH);
ERROR_IF(out_pad_left <= -KW || out_pad_right <= -KW);
ERROR_IF(stride_y < 1 || stride_x < 1);
ERROR_IF(OH != (IH - 1) * stride_y + out_pad_top + out_pad_bottom + KH);
ERROR_IF(OW != (IW - 1) * stride_x + out_pad_left + out_pad_right + KW);
ERROR_IF(BC != OC && BC != 1);

for_each(0 <= n < N, 0 <= iy < IH, 0 <= ix < IW, 0 <= dy < stride_y, 0 <= dx < stride_x, 0 <= oc < OC) {
    acc_t acc = 0;
    index_t oy = iy * stride_y + dy + out_pad_top;
    index_t ox = ix * stride_x + dx + out_pad_left;

    for_each(0 <= sy * stride_y < KY - dy, 0 <= sx * stride_x < KX - dx, 0 <= ic < IC) {
        index_t y = iy - sy;
        index_t x = ix - sx;
        index_t ky = dy + sy * stride_y;
        index_t kx = dx + sx * stride_x;
        acc_t value = static_cast<acc_t>(tensor_read<in_t>(input, [N,IH,IW,IC], [n,y,x,ic]));
        acc_t weight_value = static_cast<acc_t>(tensor_read<weight_t>(weight, [OH,KH,KW,IC], [oc,ky,kx,ic]));
        value = apply_sub_s<acc_t>(value, static_cast<acc_t>(input_zp));
        weight_value = apply_sub_s<acc_t>(weight_value, static_cast<acc_t>(weight_zp));
        acc = apply_add_s<acc_t>(acc, apply_mul_s<acc_t>(value, weight_value));
    }

    out_t out = static_cast<out_t>(acc);
    out = apply_add_s<out_t>(out, bias[(BC == 1) ? 0 : oc]);
    tensor_write<out_t>(output, [N,OH,OW,OC], [n,oy,ox,oc], out);
}
