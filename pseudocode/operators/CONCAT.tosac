//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

ERROR_IF(input1 == []); // There must be at least one input in the input list
ERROR_IF(axis < 0 || axis >= max(1,rank(shapes1[0])));

// The following checks ensure all inputs are compatible for concatenation
// Iterate over each shape and dimension
// All shapes must have the same rank
// If the dimension is the axis dimension, sum the size of this dimension to check
// that the size of the output equals the size of the concatenated shapes
// For all other dimensions, the size must match for all inputs

tensor_size_t axis_sum = 0;
for (int32_t shape_index = 0; shape_index < length(shapes1); shape_index++) {
    ERROR_IF(rank(shapes1[shape_index]) != rank(shapes1[0]));
    for (int32_t axis_index = 0; axis_index < length(shapes1[0]); axis_index++) {
        if (axis_index == axis) {
            axis_sum += shapes1[shape_index][axis_index];
        }
        else {
            ERROR_IF(shapes1[shape_index][axis_index] != shapes1[0][axis_index]);
        }
    }
}
ERROR_IF(axis_sum != shape[axis]);

for_each_data_position(index1 in shape) {
    shape_t index2 = index1;
    for (int32_t t = 0; t < length(input1); t++) {
        // Continue to concatenate along axis from each tensor
        // For each output location, we are looking for the
        // appropriate input tensor
        if (index2[axis] >= 0 && index2[axis] < shape_dim(shapes1[t], axis)) {
            in_out_t value = tensor_read<in_out_t>(input1[t], shapes1[t], index2);
            tensor_write<in_out_t>(output, shape, index1, value);
        }
        index2[axis] = index2[axis] - shape_dim(shapes1[t], axis);
    }
}

