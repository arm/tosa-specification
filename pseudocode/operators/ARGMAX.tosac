//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

ERROR_IF(axis < 0 || axis >= rank(shape1));
shape_t left_shape, right_shape;
if (axis == 0) {
    left_shape = [];
} else {
    left_shape = shape1[0:axis - 1];
}
if (axis == rank(shape1)-1) {
    right_shape = [];
} else {
    right_shape = shape1[axis+1:rank(shape1) - 1];
}
ERROR_IF(flatten(left_shape, right_shape) != shape);
for_each_data_position(left_index in left_shape) {
    for_each_data_position(right_index in right_shape) {
        in_t max_value = (is_floating_point<in_t>() && nan_mode == IGNORE)
                             ? nan<in_t>()
                             : minimum_s<in_t>();
        out_t max_index = 0;
        for (tensor_size_t i = 0; i < shape1[axis]; i++) {
            shape_t index = flatten(left_index, [i], right_index);
            in_t value = tensor_read<in_t>(input, shape1, index);
            in_t result = apply_max_s<in_t>(value, max_value, nan_mode);
            if (result != max_value) {
                if (!(isNaN(result) && isNaN(max_value))) {
                    max_value = result;
                    max_index = i;
                }
            }
        }
        shape_t index = flatten(left_index, right_index);
        tensor_write<out_t>(output, shape, index, max_index);
    }
}
