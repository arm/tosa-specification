//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

fp64_t exp2(int n) {
    if (n < -1075) {
        return 0.0; // smaller than smallest denormal
    }
    REQUIRE(n <= 1023);
    fp64_t v = 1.0;
    while (n > 0) { v = v*2.0; n--; }
    while (n < 0) { v = v/2.0; n++; }
    return v;
}

int ilog2(fp64_t v) {
    REQUIRE(0 < v && v < infinity);
    int n = 0;
    while (v >= 2.0) { v = v/2.0; n++; }
    while (v <  1.0) { v = v*2.0; n--; }
    return n;
}

fp64_t normal_min<in_t>() {
  if (is_same<in_t,fp32_t>()) {
    return exp2(-126);
  } else if (is_same<in_t,bf16_t>()) {
    return exp2(-126);
  } else if (is_same<in_t,fp16_t>()) {
    return exp2( -14);
  } else if (is_same<in_t,fp8e4m3_t>()) {
    return exp2(-6);
  } else if (is_same<in_t,fp8e5m2_t>()) {
    return exp2(-14);
  } else if (is_same<in_t,fp6e2m3_t>()) {
    return 1.0;
  } else if (is_same<in_t,fp6e3m2_t>()) {
    return 0.25;
  } else if (is_same<in_t,fp4e2m1_t>()) {
    return 1.0;
  } else if (is_same<in_t,mxint8_t>()) {
    return 1/64.0;
  } else if (is_same<in_t,fp8ue8m0_t>()) {
    return exp2(-127);
}

fp64_t normal_max<in_t>() {
  if (is_same<in_t,fp32_t>()) {
    return exp2(128) - exp2(127-23);
  } else if (is_same<in_t,bf16_t>()) {
    return exp2(128) - exp2(127-7);
  } else if (is_same<in_t,fp16_t>()) {
    return exp2(16) - exp2(15-10);
  } else if (is_same<in_t,fp8e4m3_t>()) {
    return exp2(9) - exp2(8-2);
  } else if (is_same<in_t,fp8e5m2_t>()) {
    return exp2(16) - exp2(15-2);
  } else if (is_same<in_t,fp6e2m3_t>()) {
    return 7.5;
  } else if (is_same<in_t,fp6e3m2_t>()) {
    return 28.0;
  } else if (is_same<in_t,fp4e2m1_t>()) {
    return 6.0;
  } else if (is_same<in_t,mxint8_t>()) {
    return 1.0 + 63.0/64.0;
  } else if (is_same<in_t,fp8ue8m0_t>()) {
    return exp2(127);
  }
}

// Number of fractional (mantissa bits)
int normal_frac<in_t>() {
  if (is_same<in_t,fp32_t>()) {
    return 23;
  } else if (is_same<in_t,bf16_t>()) {
    return  7;
  } else if (is_same<in_t,fp16_t>()) {
    return 10;
  } else if (is_same<in_t,fp8e4m3_t>()) {
    return 3;
  } else if (is_same<in_t,fp8e5m2_t>()) {
    return 2;
  } else if (is_same<in_t,fp6e2m3_t>()) {
    return 3;
  } else if (is_same<in_t,fp6e3m2_t>()) {
    return 2;
  } else if (is_same<in_t,fp4e2m1_t>()) {
    return 1;
  } else if (is_same<in_t,mxint8_t>()) {
    return 0;
  }
}

// Exponent width
int exponent_bits<in_t>() {
  if (is_same<in_t, fp32_t) {
    return 8;
  } else if (is_same<in_t, fp16_t) {
    return 5;
  } else if (is_same<in_t, bf16_t) {
    return 8;
  } else if (is_same<in_t,fp8e4m3_t>()) {
    return 4;
  } else if (is_same<in_t, fp8e5m2_t>()) {
    return 5;
  } else if (is_same<in_t, fp6e2m3_t>()) {
    return 2;
  } else if (is_same<in_t, fp6e3m2_t>()) {
    return 3;
  } else if (is_same<in_t, fp4e2m1_t>()) {
    return 2;
  } else if (is_same<in_t, mxint8_t>()) {
    return 0;
  }
}

int exponent_bias<in_t>() {
  if (is_same<in_t, fp32_t) {
    return 127;
  } else if (is_same<in_t, fp16_t) {
    return 15;
  } else if (is_same<in_t, bf16_t) {
    return 127;
  } else if (is_same<in_t,fp8e4m3_t>()) {
    return 7;
  } else if (is_same<in_t, fp8e5m2_t>()) {
    return 15;
  } else if (is_same<in_t, fp6e2m3_t>()) {
    return 1;
  } else if (is_same<in_t, fp6e3m2_t>()) {
    return 3;
  } else if (is_same<in_t, fp4e2m1_t>()) {
    return 1;
  } else if (is_same<in_t, mxint8_t>()) {
    return 6;
  } else if (is_same<in_t, fp8ue8m0_t>()) {
    return 127;
  }
}

fp64_t calcAbsErrorBound<in_t>(fp64_t bound_magnitude, fp64_t bounds_value,
                               fp64_t lower_bound, fp64_t normal_divisor) {
    fp64_t error_bound = 0.0;
    // Avoid cases where we generate an error_bound of NaN by multiplying inf * 0
    if (is_finite(bounds_value) || abs(bound_magnitude) != 0.0) {
      fp64_t value_bound = max(abs(bound_magnitude), normal_min<in_t>());
      if (lower_bound > 0) {
        value_bound = max(lower_bound / bounds_value, value_bound);
      }
      error_bound = exp2(-normal_frac<in_t>() / normal_divisor) * value_bound;
      error_bound = error_bound * bounds_value;
    }
    return error_bound;
}