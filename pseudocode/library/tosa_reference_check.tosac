//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2025 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

bool_t tosa_reference_check_fp_bnd<in_t>(in_t test_value, fp64_t ref_value, fp64_t err_bnd) {
  if (is_a_NaN(ref_value)) {
    // If the reference value is a NaN, the test value must also be any NaN.
    return is_a_NaN(test_value);
  }
  if (!is_finite(err_bnd)) {
    return true;
  }
  REQUIRE(err_bnd >= 0.0);
  if (ref_value < 0) {
    ref_value  = -ref_value;
    test_value = -test_value;
  }

  fp64_t ref_max = ref_value + err_bnd;
  fp64_t ref_min = ref_value - err_bnd;

  if (ref_max > normal_max<in_t>()) ref_max = infinity;
  if (ref_min > normal_max<in_t>()) ref_min = infinity;
  if (ref_min < -normal_max<in_t>()) ref_min = -infinity;

  if (is_same<in_t,bf16_t>() || is_same<in_t,fp16_t>() || is_same<in_t,fp32_t>()) {
    // Allow subnormal values to be flushed to zero for non-fp8
    if (test_value == 0) return (ref_min < normal_min());
  }

  if (is_same<in_t,fp8e4m3_t>() && is_a_NaN(test_value)) {
    // The case where ref is NaN is handled at the beginning of the function
    // The following check is enough because `abs(ref_max) >= abs(ref_min)` and
    // `ref_max >= 0`.
    return ref_max == infinity;
  }

  // Overflow/subnormals have been handled, can do a standard check
  // at this point.
  return (static_cast<fp64_t>(test_value) >= ref_min &&
          static_cast<fp64_t>(test_value) <= ref_max);
}

fp64_t tosa_reference_ulp<in_t>(fp64_t ref_value) {
  if (is_normal_fp64(ref_value) && abs(ref_value) != 0) {
    int ref_exp = ilog2(abs(ref_value));
    fp64_t ref_pow2 = max(exp2(ref_exp), normal_min<in_t>());
    return ref_pow2 * exp2(-normal_frac<in_t>());
  }
  return 0.0;
}

bool_t tosa_reference_check_fp<in_t>(in_t test_value, fp64_t ref_value, fp64_t num_ulp) {
  fp64_t err_bnd = tosa_reference_ulp<in_t>(ref_value) * num_ulp;
  return tosa_reference_check_fp_bnd<in_t>(test_value, ref_value, err_bnd);
}
