//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2024-2025 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

bool_t tosa_reference_check_dotproduct<OP, in_t, weight_t, out_t, acc_t>(
    i32_t S,             // test set number
    T<in_t> input,       // input tensor
    T<weight_t> weight,  // weight tensor
    T<out_t> bias        // bias tensor
) {
    T<in_t>     input_abs  = max(abs(input),  normal_min<in_t>()); // Element-wise
    T<weight_t> weight_abs = max(abs(weight), normal_min<in_t>()); // Element-wise
    T<out_t>    bias_abs   = max(abs(bias),   normal_min<in_t>()); // Element-wise
    if (!local_bound) {
        in_t input_abs_max = max_value(input_abs);  // maximum over all elements
        for_each_data_position(index in shape(input_abs)) {
            input_abs[index] = input_abs_max;  // set all entries to global maximum
        }
    }
    // reference_fp64(OP) calculates the results of operation OP using fp64_t arithmetic
    // implementation(OP) runs operation OP using the implementation under test
    T<out_t>  output_imp = implementation(OP, input, weight, bias, tosa_extra_multiplies = IMPLEMENTATION_DEFINED);
    T<fp64_t> output_ref = reference_fp64(OP, input, weight, bias, tosa_extra_multiplies = false);
    T<fp64_t> output_bnd = reference_fp64(OP, input_abs, weight_abs, bias_abs, tosa_extra_multiplies = true);

    tensor_size_t T = tensor_size(output_shape);  // number dot product results
    tensor_size_t ksb = ceil(KS / pow(2, (normal_frac<acc_t>() - normal_frac<out_t>())/2)) + ((max_value(bias_abs) > 0) ? 1 : 0);
    fp64_t out_err_sum = 0.0;
    fp64_t out_err_sumsq = 0.0;
    for_each_data_position(index in output_shape) {
        fp64_t out_bnd_el = tensor_read<fp64_t>(output_bnd, output_shape, index);
        fp64_t out_ref_el = tensor_read<fp64_t>(output_ref, output_shape, index);
        acc_t  out_imp_el = tensor_read<acc_t> (output_imp, output_shape, index);
        fp64_t out_err;

        if (is_a_NaN(out_ref_el)) {
            // Reference is a NaN on non-padded data, the implementation must match
            if (!is_a_NaN(out_imp_el)) {
                return false;
            }
            out_err = 0.0;
        } else if (is_a_NaN(out_bnd_el)) {
            // No further accuracy requirements for a NaN bound
            out_err = 0.0;
        } else if.(static_cast<out_t>(out_bnd_el * (1 + ABS_BOUND * exp2(-1-normal_frac<out_t>()))) == infinity) {
            // dot product can overflow within error bound and there is no accuracy limit
            out_err = 0.0;
        } else if (out_bnd_el == 0.0) {
            // All products in the dot product are zero
            if (out_ref_el != 0.0 || out_imp_el != 0.0) {
                return false;
            }
            out_err = 0.0;
        } else {  // 0.0 < out_bnd < infinity
            fp64_t out_err_bnd = max(out_bnd_el * exp2(-1-normal_frac<out_t>()), normal_min<out_t>());
            out_err = (static_cast<fp64_t>(out_imp_el) - out_ref_el) / out_err_bnd;
            // Check the absolute error. See the table for the definition of ABS_BOUND.
            if (abs(out_err) > ABS_BOUND) {
                return false;
            }
        }
        out_err_sum   += out_err;
        out_err_sumsq += out_err * out_err;
    }
    // Only check this for input and weights for test data sets 3-5
    if ( S >= 3 && S <= 5) {
        // check output error bias magnitude for data sets S which are not positive biased
        // The factor 10 allows for up to a 4 sigma difference of the error sum around the
        // expected error sum assuming errors are normally distributed.
        if (abs(out_err_sum) > sqrt(10 * VARIANCE_ERROR_BOUND * T)) {
            return false;
        }
    }
    // check output error variance magnitude
    // See the table for the definition of VARIANCE_ERROR_BOUND
    if (out_err_sumsq > VARIANCE_ERROR_BOUND * T) {
        return false;
    }
    return true;
}
