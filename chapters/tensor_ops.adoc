//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

=== Tensor Operators

==== ARGMAX

This returns the index with the largest value across the given axis of the input tensor.
If multiple locations have equal values, returns the first match along the search axis.

*Precision Requirements*

Integer results must be exact.

NaN propagation mode only affects floating-point types.
It indicates either propagating or ignoring NaN.

For floating-point input, the following rules apply:

* In the NaN propagating mode, NaN values always compare as greater than non-NaN values.
* In the NaN ignoring mode, NaN values always compare as less than non-NaN values.
* The sign of zero is ignored when comparing values.
* Infinities of the same sign compare as equal.
* All NaN values compare as equal to other NaN values.

include::{generated}/operators/ARGMAX.adoc[]

[source,c++]
----
include::{pseudocode}/operators/ARGMAX.tosac[lines=10..-1]
----

==== AVG_POOL2D

This performs an average pooling over the given input tensor.
A sliding window of size given by <kernel size> is passed over the input tensor, with the mean value being placed in the output tensor.
When calculating the average, only the number of valid input tensor values, but not padding, are used to calculate the divisor.

*Precision Requirements*

Integer results must be exact.

For floating-point values, the following rules apply:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Outputs can be expressed as a dot product of an input vector with a vector with elements 1/KS where KS is the kernel size.
* This dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/AVG_POOL2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/AVG_POOL2D.tosac[lines=10..-1]
----

==== CONV2D

Performs a 2D convolution over the given tensor input, using the weight tensor.
Implementations may choose to skip calculation of multiplies in the padding area.

*Precision Requirements*

Integer results must be exact.

For floating-point values, the following rules apply:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of two input vectors.
* The dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/CONV2D.tosac[lines=10..-1]
----

==== CONV3D

Performs a 3D convolution over the given input tensor.
Implementations may choose to skip calculation of multiplies in the padding area.

*Precision Requirements*

Integer results must be exact.

For floating-point values, the following rules apply:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of two input vectors.
* The dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/CONV3D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/CONV3D.tosac[lines=10..-1]
----

==== DEPTHWISE_CONV2D

Performs 2D convolutions separately over each channel of the given tensor input, using the weight tensor.
Implementations may choose to skip calculation of multiplies in the padding area.

*Precision Requirements*

Integer results must be exact.

For floating-point values, the following rules apply:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of two input vectors.
* The dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/DEPTHWISE_CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/DEPTHWISE_CONV2D.tosac[lines=10..-1]
----

==== FFT2D

Performs a batched complex 2D Fast Fourier Transform over the input.
The complex input values are constructed from the corresponding values in the input_real and input_imag tensors.
The resulting values in the output are split into the output_real and output_imag tensors.
No normalization is applied on either the forward or inverse versions of the operation.

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(-2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

.Calculation for the forward FFT2D calculation (inverse=false)
image::forward_fft2d.svg["forward FFT definition", align="center"]

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

.Calculation for the inverse FFT2D calculation (inverse=true)
image::inverse_fft2d.svg["inverse FFT definition", align="center"]

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of an input vector with a constant coefficient vector.
* The following may be used to validate the output
** Let `input_real` be the real input tensor.
** Let `input_imag` be the imaginary input tensor.
** Let `weight_real` be the coefficient vector tensor of real values.
** Let `weight_imag` be the coefficient vector tensor of imaginary values.
** Let `input` be an interleaved tensor of real values from input tensors `input_real` and `input_imag` such that `input = [input_real[0], input_imag[0], input_real[1], input_imag[1], ...]` and `shape(input) = [N,H,W*2]`.
** Let `weight` be an interleaved tensor of real values from weight tensors `weight_real` and `weight_imag` such that `weight = [weight_real[0], weight_imag[0], weight_real[1], weight_imag[1], ...]` and `shape(weight) = [N,H,W*2]`.
** Let `FFT_Real` be the operation that calculates the real output (`output_real`).
** Let `FFT_Imag` be the operation that calculates the imaginary output (`output_imag`).
** For all `S` in the defined data sets in Appendix A <<Floating-Point Operator Test Data>>.
*** `tosa_reference_check_dotproduct<FFT_Real, in_out_t, in_out_t, in_out_t, in_out_t>(S, input, weight, [])` must be true.
*** `tosa_reference_check_dotproduct<FFT_Imag, in_out_t, in_out_t, in_out_t, in_out_t>(S, input, weight, [])` must be true.

include::{generated}/operators/FFT2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/FFT2D.tosac[lines=10..-1]
----

==== MATMUL

Performs two dimensional matrix multiplications.

*Precision Requirements*

Integer results must be exact.

For floating-point values, the following rules apply:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of two input vectors.
* The dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/MATMUL.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MATMUL.tosac[lines=10..-1]
----

==== MAX_POOL2D

This performs a max pooling over the given input tensor.
A sliding window of size given by <kernel size> is passed over the input tensor, with the maximum value being placed in the output tensor.

*Precision Requirements*

Integer results must be exact.

NaN propagation mode only affects floating-point types.
It indicates either propagating or ignoring NaN.

The following rules apply to floating-point inputs:

* Comparison rules:
** The sign of a zero is ignored.
** Infinities of the same sign compare as equal.
** In the NaN propagating mode, if any input in the window is a NaN then the result must be NaN.
** In the NaN ignoring mode, if all inputs in the window are NaN, the result is NaN.
Otherwise the result is the maximum non-NaN value in the window.
* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* If a floating-point result is zero, then the result must be either +0.0 or -0.0 but either sign is permitted.
* If the result is a subnormal value for bf16_t, fp16_t, or fp32_t, the result may be a zero of either sign.

include::{generated}/operators/MAX_POOL2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MAX_POOL2D.tosac[lines=10..-1]
----

==== RFFT2D

Performs a batched 2D real-valued Fast Fourier Transform over the input where the input tensor consists of real values producing complex valued output.
The complex output values will be split into the output_real and output_imag tensor arguments.
RFFT2D takes advantage of Hermitian symmetry to only calculate the first half of the final output axis.
Implementations may choose to skip calculation of the imaginary values at (0,0), (0,W/2), (H/2,0), and (H/2, W/2).
If the calculation is skipped, the result at that location must be zero.

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(-2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

image::forward_fft2d.svg["forward RFFT definition", align="center"]

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of an input vector with a constant coefficient vector.
* The following may be used to validate the output
** Let `RFFT_Real` be the operation that calculates the real output (`output_real`).
** Let `RFFT_Imag` be the operation that calculates the imaginary output (`output_imag`).
** Let `input` be the input tensor.
** Let `weight_real` be the coefficient vector tensor of real values.
** Let `weight_imag` be the coefficient vector tensor of imaginary values.
** For all `S` in the defined data sets in Appendix A <<Floating-Point Operator Test Data>>.
*** `tosa_reference_check_dotproduct<RFFT_Real, in_out_t, in_out_t, in_out_t, in_out_t>(S, input, weight_real, [])` must be true.
*** `tosa_reference_check_dotproduct<RFFT_Imag, in_out_t, in_out_t, in_out_t, in_out_t>(S, input, weight_imag, [])` must be true.

include::{generated}/operators/RFFT2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/RFFT2D.tosac[lines=10..-1]
----

==== TRANSPOSE_CONV2D

Performs a 2D transposed convolution over the given tensor input, using the weights tensor.
Implementations may choose to skip calculation of multiplies by zero at fractional input positions.

*Precision Requirements*

Integer results must be exact.

The following rules apply to floating-point inputs:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Each output can be expressed as a dot product of two input vectors.
* The dot product must meet the <<Dot product accuracy requirements>>.

include::{generated}/operators/TRANSPOSE_CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/TRANSPOSE_CONV2D.tosac[lines=10..-1]
----
