//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2024 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

=== Tensor Operators

==== ARGMAX

This returns the index with the largest value across the given axis of the input tensor.
If multiple locations have equal values, returns the first match along the search axis.
NaN values always compare as greater than non-NaN values.
If an entire axis consists of NaN, the last location must be returned.

include::{generated}/operators/ARGMAX.adoc[]

[source,c++]
----
include::{pseudocode}/operators/ARGMAX.tosac[lines=10..-1]
----

==== AVG_POOL2D

This performs an average pooling over the given input tensor.
A sliding window of size given by <kernel size> is passed over the input tensor, with the mean value being placed in the output tensor.
When calculating the average, only the number of valid input tensor values, but not padding, are used to calculate the divisor.

include::{generated}/operators/AVG_POOL2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/AVG_POOL2D.tosac[lines=10..-1]
----

==== CONV2D

Performs a 2D convolution over the given tensor input, using the weight tensor.

include::{generated}/operators/CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/CONV2D.tosac[lines=10..-1]
----

==== CONV3D

Performs a 3D convolution over the given input tensor.

include::{generated}/operators/CONV3D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/CONV3D.tosac[lines=10..-1]
----

==== DEPTHWISE_CONV2D

Performs 2D convolutions separately over each channel of the given tensor input, using the weight tensor.

include::{generated}/operators/DEPTHWISE_CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/DEPTHWISE_CONV2D.tosac[lines=10..-1]
----

==== FFT2D

Performs a batched complex 2D Fast Fourier Transform over the input.
The complex input values are constructed from the corresponding values in the input_real and input_imag tensors.
The resulting values in the output are split into the output_real and output_imag tensors.
No normalization is applied on either the forward or inverse versions of the operation.

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(-2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

.Calculation for the forward FFT2D calculation (inverse=false)
image::forward_fft2d.svg["forward FFT definition", align="center"]

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

.Calculation for the inverse FFT2D calculation (inverse=true)
image::inverse_fft2d.svg["inverse FFT definition", align="center"]

include::{generated}/operators/FFT2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/FFT2D.tosac[lines=10..-1]
----

==== FULLY_CONNECTED

Performs a fully connected network.

include::{generated}/operators/FULLY_CONNECTED.adoc[]

[source,c++]
----
include::{pseudocode}/operators/FULLY_CONNECTED.tosac[lines=10..-1]
----

==== MATMUL

Performs two dimensional matrix multiplications. This allows both inputs to be activations, rather than reserving weights as an attribute in the FULLY_CONNECTED operator.

include::{generated}/operators/MATMUL.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MATMUL.tosac[lines=10..-1]
----

==== MAX_POOL2D

This performs a max pooling over the given input tensor. A sliding window of size given by <kernel size> is passed over the input tensor, with the maximum value being placed in the output tensor.

include::{generated}/operators/MAX_POOL2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MAX_POOL2D.tosac[lines=10..-1]
----

==== RFFT2D

Performs a batched 2D real-valued Fast Fourier Transform over the input where the input tensor consists of real values producing complex valued output.
The complex output values will be split into the output_real and output_imag tensor arguments.
RFFT2D takes advantage of Hermitian symmetry to only calculate the first half of the final output axis.
Imaginary values with locations (0,0), (0,W/2), (H/2,0) and (H/2,W/2) are zero.

// output[h][w] = \sum_{m=0}^{H-1}\sum_{n=0}^{W-1}input[m][n] * \exp\left(-2\pi i\left(\frac{mh}{H} + \frac{nw}{W}\right)\right)

image::forward_fft2d.svg["forward RFFT definition", align="center"]

include::{generated}/operators/RFFT2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/RFFT2D.tosac[lines=10..-1]
----

==== TRANSPOSE_CONV2D

Performs a 2D transposed convolution over the given tensor input, using the weights tensor.

include::{generated}/operators/TRANSPOSE_CONV2D.adoc[]

[source,c++]
----
include::{pseudocode}/operators/TRANSPOSE_CONV2D.tosac[lines=10..-1]
----
