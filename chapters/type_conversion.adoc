//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2025 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

=== Type Conversion

==== CAST

Casts a tensor from one data type to another.

include::{generated}/operators/CAST.adoc[]

*Precision Requirements*

When casting between integer types, the results must be exact.

Rules when casting between floating-point types:

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* If the input value is a NaN, a NaN of the output type must be returned.
* The following sequence describes conversion between floating-point types:
** The mantissa of the input value is converted to the mantissa size of the output format, with rounding if needed.
** If the resulting value is below the minimum subnormal number magnitude for the target format, a zero of the appropriate sign must be returned.
** For bf16_t, fp16_t, and fp32_t, if the resulting value is below the minimum normal number magnitude for the target format, either the corresponding subnormal value may be returned, or a zero of the appropriate sign may be returned.
** If the output type is fp8e4m3_t or fp8e5m2_t the result must use the non-saturating conversion mode defined in <<OCP-OFP8,OCP-OFP8>>.
** Otherwise if the resulting value is outside of the output representable range, an infinity of the appropriate sign must be returned.
* If the input value is inside the output representable range then the following accuracy must be met:
** Let `x` be an input element.
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Let `ulp = tosa_reference_ulp<out_t>(out_ref)` define one ulp of error.
** Then `abs(out_ref) - ulp \<= abs(x) \<= abs(out_ref) + 0.5*ulp` must be true and `x` must have the correct sign.
** This allows for both round to zero and round to nearest rounding modes.

Rules when casting between different types:

* Casting from floating-point to integer:
** Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
** If any input is a NaN, the result is unpredictable.
** Result overflows must be saturated.
** Conversion must use the round to nearest, ties to even rounding mode.
* Casting from integer to floating-point:
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Then `tosa_reference_check_fp<out_t>(out_imp, out_ref, 0.5)` must be true.
* Casting to boolean type:
** The result must be exact.

[source,c++]
----
include::{pseudocode}/operators/CAST.tosac[lines=10..-1]
----

==== RESCALE

RESCALE is defined using an integer multiply, add, and shift.

Rescale supports two precisions of multiplier: 16-bit and 32-bit.
The 32-bit multiplier version supports two rounding modes to enable simpler lowering of existing frameworks that use two stage rounding.
All arithmetic is designed so that it does not overflow a 64-bit accumulator and that the result fits in 32 bits.
In particular, a 48-bit value cannot be scaled with the 32-bit multiplier because the accumulator would need to have 80 bits.

The apply_scale_* functions provide a scaling of approximately (multiplier / 2^shift^).

The shift and value range are limited to allow a variety of implementations.
The limit of 62 on shift allows the shift to be decomposed as two right shifts of 31.

For apply_scale_32, the value must be between `(-1 << (shift - 1)) \<= value < (1 << (shift - 1))`.
This allows for implementations that left-shift the value before the multiply in the case of shifts of 32 or less.

For example, in the case shift=30 an implementation of the form `((value\<<2) * multiplier + round)>>32` can be used.
A scaling range of 2^+12^ down to 2^-32^ is supported for both functions with a normalized multiplier.

In typical usage, a scaling of `m*2^-n^` (where m is a fraction in the range `1.0 \<= m < 2.0`) can be represented using `multiplier=(1<<30)*m, shift=(30+n)` for apply_scale_32() and `multiplier=(1<<14)*m, shift=(14+n)` for apply_scale_16().

The values to achieve a scaling of 1.0 are `shift=30, multiplier=1<<30` for apply_scale_32 and `shift=14, multiplier=1<<14` for apply_scale_16.

The right shift of result is an arithmetic shift.

For implementation details of the apply_scale_functions, see <<Scaling Helpers>>.

*Precision Requirements*

If rounding_mode is SINGLE_ROUND or DOUBLE_ROUND, results must be exact.

If rounding_mode is INEXACT_ROUND, the following must be true:

* Let `x` be the input value to be rescaled.
* Let `m` be the scaling multiplier.
* Let `out_ref = (x - input_zp) * m * exp2(-shift)` be the result calculated using fp64_t arithmetic.
* Note (informational): The error bound is 0.5 for the final output rounding error plus three relative errors from casting the activation input, multiplier input, and floating-point multiply. +
A SINGLE_ROUND exact implementation will automatically meet this error bound since the rounding error of SINGLE_BOUND is at most 0.5.
* Let `err_bnd = 0.5 + 3 * abs(out_ref) * exp2(-normal_frac<fp32>() - 1)`.
* Let `out_ref_min = apply_clip_s<fp64_t>(apply_ceil<fp64_t>(out_ref - err_bnd + output_zp), minimum_s<out_t>, maximum_s<out_t>)`.
* Let `out_ref_max = apply_clip_s<fp64_t>(apply_floor<fp64_t>(out_ref + err_bnd + output_zp), minimum_s<out_t>, maximum_s<out_t>)`.
* Let `out_ref_min_int = static_cast<out_t>(out_ref_min)`.
* Let `out_ref_max_int = static_cast<out_t>(out_ref_max)`.
* Let `out_imp` be the implementation output.
* Then `out_ref_min_int \<= out_imp \<= out_ref_max_int` must be true.


include::{generated}/operators/RESCALE.adoc[]

[source,c++]
----
include::{pseudocode}/operators/RESCALE.tosac[lines=10..-1]
----
