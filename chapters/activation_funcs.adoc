//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2025 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.


=== Activation Functions

==== CLAMP

Clamp to an arbitrary minimum and maximum value.
Maximum and minimum values are specified as values in the range of the input type.
No zero point subtraction is done to the values, thus to clamp to the zero point value, the zero point itself should be supplied as the minimum value.

*Precision Requirements*

Integer results must be exact.

NaN propagation mode only affects floating-point types.
It indicates either propagating or ignoring NaN.

The following rules apply to floating-point inputs:

* Comparison rules:
** The sign of a zero is ignored.
** Infinities of the same sign compare as equal.
** In the NaN propagating mode, if the input is a NaN, the output must be a NaN.
** In the NaN ignoring mode, if the input is a NaN, the output is the specified minimum value.
* bf16_t, fp16_t, and fp32_t subnormal values may be flushed to zero before computation.
* If a floating-point result is zero, then the result must be either +0.0 or -0.0 but either sign is permitted.
* If the result is a subnormal value for bf16_t, fp16_t, or fp32_t, the result may be a zero of either sign.

include::{generated}/operators/CLAMP.adoc[]

[source,c++]
----
include::{pseudocode}/operators/CLAMP.tosac[lines=10..-1]
----

==== ERF

// erf(z) = \frac{2}{\sqrt{\pi}} \int_{0}^{z} e^{-t^2} dt
Error function:

.Calculation for the error function
image::erf.svg["Error function", align="center"]

For quantized integer data types, the TABLE operator should be used instead with
the following definition.

The ERF table has 513 entries each of 16-bit precision and covering the input range -4.0 to +4.0 in steps of 1/64.

[source,c++]
----
include::{pseudocode}/operators/tables/ERF.tosac[lines=10..-1]
----

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* The following may be used to validate the result:
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Then `tosa_reference_check_fp<in_t>(out_imp, out_ref, 5)` must be true.

include::{generated}/operators/ERF.adoc[]

[source,c++]
----
include::{pseudocode}/operators/ERF.tosac[lines=10..-1]
----

==== SIGMOID

Applies the sigmoid logistic function to each element of the input tensor.

// sigmoid(x) = \frac{1}{1 + e^{-x}}

.Calculation for the sigmoid function
image::sigmoid.svg["Sigmoid definition"]

For quantized integer data types, the TABLE operator should be used instead.
Each implementation may choose an appropriate TABLE given the scale and zero point of the input data.
Eight or sixteen bit precision tables may be used based on the input tensor to the sigmoid function.
Below we give an example table generation for 16-bit sigmoid.
This sigmoid table has 513 entries each of 16-bit precision and covering the input range -16.0 to +16.0 in steps of 1/16.

.Code for generating 16-bit sigmoid table
[source,c++]
----
include::{pseudocode}/operators/tables/SIGMOID.tosac[lines=10..-1]
----

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Infinity, NaN, and Zero behavior as defined in the following table.
* Otherwise the following may be used to validate the result:
** Let `x` be an input element.
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Let `err_bnd = calcAbsErrorBound<in_out_t>(out_ref, 2 * (1+abs(x)), 0, 1)`.
** Then `tosa_reference_check_fp_bnd<in_out_t>(out_imp, out_ref, err_bnd)` must be true.

include::{generated}/operators/SIGMOID.adoc[]

*Floating-point behavior:*
|===
|Input|-infinity|+infinity|-0|+0|NaN

|Output|0|1|0.5|0.5|any NaN
|===

[source,c++]
----
include::{pseudocode}/operators/SIGMOID.tosac[lines=10..-1]
----

==== TANH

Parameterized hyperbolic tangent.
// tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}}

.Calculation for the tanh function
image::tanh.svg["Hyperbolic tangent definition"]

For quantized integer data types, the TABLE operator should be used instead.
Each implementation may choose an appropriate TABLE given the scale and zero point of the input data.
Eight or sixteen bit precision tables may be used based on the input tensor to the tanh function.
Below we give an example table generation for 16-bit hyperbolic tangent.
This tanh table has 513 entries each of 16-bit precision and covering the input range -8.0 to +8.0 in steps of 1/32.

.Calculation of an example 16-bit tanh table
[source,c++]
----
include::{pseudocode}/operators/tables/TANH.tosac[lines=10..-1]
----

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Infinity, NaN, and Zero behavior as defined in the following table.
* Otherwise the following may be used to validate the result:
** Let `x` be an input element.
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
*** Note (informational): The error bound is derived from the error bound for the exp operator based on implementation of TANH as `(exp(x) - exp(-x)) / (exp(x) + exp(-x))`.
*** The absolute lower bound of 0.5 ulp relative to 1.0 is due to `exp(x) - exp(-x)` having an error of this magnitude when x is close to 0.
** Let `exp_err_base = is_same<in_out_t, fp32_t>() ? 3 : 1`.
** Let `err_bnd = calcAbsErrorBound<in_out_t>(out_ref, 4 * (exp_err_base + 2 * abs(x)), 0.5, 1)`.
** Then `tosa_reference_check_fp_bnd<in_out_t>(out_imp, out_ref, err_bnd)` must be true.

include::{generated}/operators/TANH.adoc[]

*Floating-point behavior:*
|===
|Input|-infinity|+infinity|-0|+0|NaN

|Output|-1|1|-0|0|any NaN
|===

[source,c++]
----
include::{pseudocode}/operators/TANH.tosac[lines=10..-1]
----
