//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2021 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.


=== Activation Functions

==== CLAMP
Clamp to an arbitrary minimum and maximum value.
Maximum and minimum values are specified as values in the range of the input type.
No zero point subtraction is done to the values, thus to clamp to the zero point value, the zero point itself should be supplied as the minimum value.

*Arguments:*

|===
|Argument|Type|Name|Shape|Description

|Input|in_out_t*|Input|shape|Input tensor
|Attribute|in_out_t|min_val|-|minimum clip value
|Attribute|in_out_t|max_val|-|maximum clip value
|Output|in_out_t*|Output|shape|Output tensor of same type and shape as input
|===

*Operation Function:*
[source,c++]
----
ERROR_IF(max_val < min_val);
for_each(index in shape) {
    in_out_t value = tensor_read<in_out_t>(input, shape, index);
    value = apply_clip<in_out_t>(value, min_val, max_val);
    tensor_write<in_out_t>(output, shape, index, value);
}
----

*Supported Data Types:*

|===
|Profile|Mode|in_out_t

|Any|signed 8|int8_t
|Any|signed 16|int16_t
|MI, MT|floating-point|float_t
|===

==== SIGMOID

Sigmoid function: output = 1 / (1 + exp(-input))

For quantized integer data types, the TABLE operator should be used instead with
the following definition.

The sigmoid table has 513 entries each of 16-bit precision and covering the input range -16.0 to +16.0 in steps of 1/16.

[source,c++]
----
int sigmoid_reference(int x) {|// input x range is -256 to + 256 inclusive
    F64 v = (double)x / (double)16;
    v = 1.0/(1.0 + exp(-v));
    return round_to_nearest_int(32768.0 * v);
}

generate_lookup_table(&sigmoid_table, &sigmoid_reference);
----

*Arguments:*

|===
|Argument|Type|Name|Shape|Description

|Input|in_out_t*|Input|shape|Input tensor
|Output|in_out_t*|Output|shape|Output tensor of same type and shape as input
|===

*Supported Data Types:*

|===
|Profile|Mode|in_out_t

|MI, MT|floating-point|float_t
|===

==== TANH

Parameterized hyperbolic tangent.

For quantized integer data types, the TABLE operator should be used instead with
the following definition.

The tanh_table has 513 entries each of 16-bit precision and covering the input range -8.0 to +8.0 in steps of 1/32. The table is specified by:

[source,c++]
----
int tanh_reference(int x) {  // input x range is -256 to +256 inclusive
    F64 v = (double)x/(double)32;
    v = exp(-2.0*v);
    v = (1.0-v)/(1.0+v);
    return round_to_nearest_int(32768.0 * v);
}

generate_lookup_table(&tanh_table, &tanh_reference);
----

*Arguments:*

|===
|Argument|Type|Name|Shape|Description

|Input|in_out_t*|Input|shape|Input tensor
|Output|in_out_t*|Output|shape|Output tensor of same type and shape as input
|===

*Supported Data Types:*

|===
|Profile|Mode|in_out_t

|MI, MT|floating-point|float_t
|===
