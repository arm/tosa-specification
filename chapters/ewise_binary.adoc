//
// This confidential and proprietary software may be used only as
// authorised by a licensing agreement from ARM Limited
// (C) COPYRIGHT 2020-2025 ARM Limited
// ALL RIGHTS RESERVED
// The entire notice above must be reproduced on all authorised
// copies and copies may only be made to the extent permitted
// by a licensing agreement from ARM Limited.

=== Elementwise Binary Operators

==== ADD

Elementwise addition of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Integer results must be exact.

The following rules apply to floating-point inputs:

* If any input is a NaN, the result must be a NaN.
* Addition of infinities of different signs must produce a NaN.
* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Subnormal bf16_t, fp16_t, and fp32_t result values may be flushed to zero of the appropriate sign after the calculation.
* The following may be used to validate the result:
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Then `tosa_reference_check_fp<in_t>(out_imp, out_ref, 0.5)` must be true.

include::{generated}/operators/ADD.adoc[]

[source,c++]
----
include::{pseudocode}/operators/ADD.tosac[lines=10..-1]
----

==== ARITHMETIC_RIGHT_SHIFT

Elementwise arithmetic right shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/ARITHMETIC_RIGHT_SHIFT.adoc[]

[source,c++]
----
include::{pseudocode}/operators/ARITHMETIC_RIGHT_SHIFT.tosac[lines=10..-1]
----

==== BITWISE_AND

Elementwise bitwise AND of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/BITWISE_AND.adoc[]

[source,c++]
----
include::{pseudocode}/operators/BITWISE_AND.tosac[lines=10..-1]
----

==== BITWISE_OR

Elementwise bitwise OR of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/BITWISE_OR.adoc[]

[source,c++]
----
include::{pseudocode}/operators/BITWISE_OR.tosac[lines=10..-1]
----

==== BITWISE_XOR

Elementwise bitwise XOR of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/BITWISE_XOR.adoc[]

[source,c++]
----
include::{pseudocode}/operators/BITWISE_XOR.tosac[lines=10..-1]
----

==== INTDIV

Elementwise integer divide of input1 by input2.
Axis of size 1 will be broadcast as necessary.
Rank of input tensors must match.
The result of the divide is truncated towards zero.
Expected use is for operations on non-scaled integers.
Floating point divide should use RECIPROCAL and MUL.
Quantized integer divide should use TABLE (for 1/x) and MUL.


*Precision Requirements*

Results must be exact.

include::{generated}/operators/INTDIV.adoc[]

[source,c++]
----
include::{pseudocode}/operators/INTDIV.tosac[lines=10..-1]
----

==== LOGICAL_AND

Elementwise logical AND of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/LOGICAL_AND.adoc[]

[source,c++]
----
include::{pseudocode}/operators/LOGICAL_AND.tosac[lines=10..-1]
----

==== LOGICAL_LEFT_SHIFT

Elementwise logical left-shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/LOGICAL_LEFT_SHIFT.adoc[]

[source,c++]
----
include::{pseudocode}/operators/LOGICAL_LEFT_SHIFT.tosac[lines=10..-1]
----

==== LOGICAL_RIGHT_SHIFT

Elementwise logical right shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/LOGICAL_RIGHT_SHIFT.adoc[]

[source,c++]
----
include::{pseudocode}/operators/LOGICAL_RIGHT_SHIFT.tosac[lines=10..-1]
----

==== LOGICAL_OR

Elementwise logical OR of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/LOGICAL_OR.adoc[]

[source,c++]
----
include::{pseudocode}/operators/LOGICAL_OR.tosac[lines=10..-1]
----

==== LOGICAL_XOR

Elementwise logical XOR of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Results must be exact.

include::{generated}/operators/LOGICAL_XOR.adoc[]

[source,c++]
----
include::{pseudocode}/operators/LOGICAL_XOR.tosac[lines=10..-1]
----

==== MAXIMUM

Elementwise max of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Integer results must be exact.

NaN propagation mode only affects floating-point types.
It indicates either propagating or ignoring NaN.

The following rules apply to floating-point inputs:

* Comparison rules:
** The sign of a zero is ignored.
** Infinities of the same sign compare as equal.
** In the NaN propagating mode, if either input value is a NaN, the result is NaN.
** In the NaN ignoring mode, if either input value is a NaN, the result is the non-NaN element.
** If both values are NaN, the result is NaN.
* bf16_t, fp16_t, and fp32_t subnormal values may be flushed to zero before computation.
* If a floating-point result is zero, then the result must be either +0.0 or -0.0 but either sign is permitted.
* If the result is a subnormal value for bf16_t, fp16_t, or fp32_t, the result may be a zero of either sign.
* If none of the above conditions apply, the floating-point result must be exact.

include::{generated}/operators/MAXIMUM.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MAXIMUM.tosac[lines=10..-1]
----

==== MINIMUM

Elementwise minimum of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Integer results must be exact.

NaN propagation mode only affects floating-point types.
It indicates either propagating or ignoring NaN.

The following rules apply to floating-point inputs:

* Comparison rules:
** The sign of a zero is ignored.
** Infinities of the same sign compare as equal.
** In the NaN propagating mode, if either input value is a NaN, the result is NaN.
** In the NaN ignoring mode, if either input value is a NaN, the result is the non-NaN element.
** If both values are NaN, the result is NaN.
* bf16_t, fp16_t, and fp32_t subnormal values may be flushed to zero before computation.
* If a floating-point result is zero, then the result must be either +0.0 or -0.0 but either sign is permitted.
* If the result is a subnormal value for bf16_t, fp16_t, or fp32_t, the result may be a zero of either sign.
* If none of the above conditions apply, the floating-point result must be exact.

include::{generated}/operators/MINIMUM.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MINIMUM.tosac[lines=10..-1]
----

==== MUL

Elementwise multiplication (Hadamard product) of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

Integer results must be exact.

The following rules apply to floating-point inputs:

* If any input is a NaN, the result must be a NaN.
* Multiplication of an infinity by a zero must produce a NaN.
* Multiplication of two infinities must produce an infinity of the correct sign.
* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Subnormal bf16_t, fp16_t, and fp32_t result values may be flushed to zero of the appropriate sign after the calculation.
* The following may be used to validate the result:
** Let `out_imp` be the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Then `tosa_reference_check_fp<in_t>(out_imp, out_ref, 0.5)` must be true.

include::{generated}/operators/MUL.adoc[]

[source,c++]
----
include::{pseudocode}/operators/MUL.tosac[lines=10..-1]
----

==== POW

Elementwise input1 value raised to the power of input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must match.

*Precision Requirements*

* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.

* Otherwise the following may be used to validate the result.
** Let `x`, `y` be input elements from `input1` and `input2` respectively.
** Let `out_imp` be the implementation output.
** If x or y is an infinity, the result is undefined.
** If x or y is a NaN, the result is undefined.
** If x < 0, the result is undefined.
** If x == 0 and y <= 0, the result is undefined.
** If x == 0 and y > 0 then the result is 0.
** If x > 0 and y == 0 then the result is 1.
** Otherwise:
*** Let `out_ref` be the result calculated using `fp64_t` arithmetic
*** Note (informational): the error bound is derived from the error bound for the `EXP`, `MUL` and `LOG` operators to allow implementation of `POW` as `exp(y * log(x)))` for positive values of `x`.
*** Let `err_base = is_same<T, fp32_t> ? 3 : 1`.
*** Let `mul_err = calcAbsErrorBound<in_out_t>(y * log(x), 5.5, abs(0.55 * y), 1)`.
*** Let `exp_err = calcAbsErrorBound<in_out_t>(err_base + 2 * abs(y * log(x) + mul_err), 1, 0, 1)`.
*** Let `total_err_factor = expm1(mul_err) + exp_err`.
*** Let `err_bnd = out_ref * total_err_factor`.
*** Then `tosa_reference_check_fp_bnd<in_out_t>(out_imp, out_ref, err_bnd)` must be true.

include::{generated}/operators/POW.adoc[]

[source,c++]
----
include::{pseudocode}/operators/POW.tosac[lines=10..-1]
----

==== SUB

Elementwise subtraction of input1 and input2.
Axis of size 1 will be broadcast as necessary. Rank of input tensors must match.

*Precision Requirements*

Integer results must be exact.

The following rules apply to floating-point inputs:

* If any input is a NaN, the result must be a NaN.
* Subnormal bf16_t, fp16_t, and fp32_t input values may be flushed to zero before calculation.
* Subnormal bf16_t, fp16_t, and fp32_t result values may be flushed to zero of the appropriate sign after the calculation.
* The following may be used to validate the result:
** Let `out_imp` the implementation output.
** Let `out_ref` be the result calculated using fp64_t arithmetic.
** Then `tosa_reference_check_fp<in_t>(out_imp, out_ref, 0.5)` must be true.

include::{generated}/operators/SUB.adoc[]

[source,c++]
----
include::{pseudocode}/operators/SUB.tosac[lines=10..-1]
----

====   TABLE

Table lookup operation.
For int8_t TABLE operation, perform a 256 entry table lookup returning an int8_t value.
For int16_t tables, the int16_t input is treated as a fixed-point 9.7 value.
The most significant 9 bits are used to index into the table.
The fractional 7 bits are used to interpolate based on table[index] and table[index+1].
For int16_t inputs, the TABLE operator returns a 16.7 interpolated value in an int32_t.
This value can then be input to the RESCALE operator to scale to the required output data type.
Note that int16_t table has 513 values to handle table[index+1] when index=511.

An int16_t to int16_t table lookup can be constructed in TOSA as follows:

* Use the TABLE operator to produce a fixed point 16.7 interpolated result
* Use RESCALE (in_t=int32_t, out_t=int16_t, scale=1<<14, shift=21) to scale the output to int16_t range (or alternate scale as required)

*Precision Requirements*

Results must be exact.

include::{generated}/operators/TABLE.adoc[]

[source,c++]
----
include::{pseudocode}/operators/TABLE.tosac[lines=10..-1]
----
